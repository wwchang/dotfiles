# Path to your oh-my-zsh configuration.
export ZSH=$HOME/.zsh

# set stinking 256 colors TERM {{{
#
if [ -n "$XTERM_VERSION" ]; then # if terminal is xterm.
    if [ -e /usr/share/terminfo/x/xterm+256color ]; then
        export TERM="xterm-256color"
    fi
else
    export TERM="xterm-256color"
fi
if [ $COLORTERM = "rxvt-xpm" ]; then # if terminal is urxvt.
    if [ -e /usr/share/terminfo/r/rxvt-unicode-256color ]; then
        export TERM="rxvt-unicode-256color"
    fi
fi
#[ -z "$TMUX" ] && export TERM=xterm-256color
#[ -z "$TMUX" ] && export TERM="screen-256color"
if [ -n "$TMUX" ]; then # if terminal is Tmux.
    export TERM="screen-256color"
fi
# }}}

# theme {{{
# Set name of the theme to load.
# Look in ~/.oh-my-zsh/themes/
# Optionally, if you set this to "random", it'll load a random theme each
# time that oh-my-zsh is loaded.
# export ZSH_THEME="robbyrussell"
export ZSH_THEME="stardiviner"
    # source for PROMPT
    # source ~/.zsh/plugins/vundle/vundle.plugin.zsh
# export ZSH_THEME="random"
# }}}

# Set to this to use case-sensitive completion
# export CASE_SENSITIVE="true"

# Comment this out to disable weekly auto-update checks
export DISABLE_AUTO_UPDATE="true"

# Uncomment following line if you want to disable colors in ls
export DISABLE_LS_COLORS="true" # =true will let ls display @/* etc for filetype.

# Uncomment following line if you want to disable autosetting terminal title.
# export DISABLE_AUTO_TITLE="true"

# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
plugins=(git github git-flow mercurial svn gem gpg-agent ssh-agent \
    ls_colors color_cmd zsh-syntax-highlighting-filetypes zsh-syntax-highlighting \
    history-substring-search command-not-found \
    extract apt)
# source other plugins
# FIXME source $ZSH/plugins/ls_colors/LS_COLORS.zsh # A cool color LS and command line type color.
# source $ZSH/plugins/color_cmd/colorCMD.zsh # colorful typing command line

# other plugins
# zsh-syntax-highlighting
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor root)
# ZSH_HIGHLIGHT_HIGHLIGHTERS+=(myhighlighter)

autoload -Uz vcs_info
zstyle ':vcs_info:*' enable git hg bzr svn

source $ZSH/oh-my-zsh.sh

if [ -d $HOME/bin ] ; then
    PATH=$HOME/bin:$HOME/scripts:$PATH
    export PATH
fi

# powerful redirection.
# redirect stdout and stderr to file: command |& > file
# redirect to multiple file same time: command > file.1 > file.2

# colorful man page {{{
# code meaning
# ————————-
# 0      OFF
# 1       hilight
# 4       underline
# 5       blink
# 7      inverse
# 8      invisible
#
export MANWIDTH=80 # man page width.
#export PAGER="`which less` -s"
export BROWSER="$PAGER"
export LESS_TERMCAP_mb=$'\E[01;43m'
export LESS_TERMCAP_md=$'\E[04;01;36m' # section like NAME DESCRIPTION
export LESS_TERMCAP_me=$'\E[0;37m' # [
# export LESS_TERMCAP_se=$'\E[0;37m' # down
# export LESS_TERMCAP_so=$'\E[0;40;36m' # bottom status
export LESS_TERMCAP_ue=$'\E[0;37m' # ]
export LESS_TERMCAP_us=$'\E[01;33m' # options
# }}}

# ENVIRONMENT {{{
    EDITOR=vim
    export EDITOR=vim

    # for syntax highlight LESS command
    PAGER='less -X -M' export LESSOPEN="| /usr/share/source-highlight/src-hilite-lesspipe.sh %s" export LESS=' -R '

    # FVWM
    #FVWM_USERDIR=$HOME/.fvwm/
    #FVWM_DATADIR=
    #FVWM_MODULEDIR=
    #SESSION_MANAGER=
    #SESSION_MANAGER_NAME=
    #SM_SAVE_DIR=

    # locale
    export LC_ALL=en_US.utf-8
    export LANG=en_US.UTF-8
# }}}

# dircolors {{{
# here -b in for command dircolors is only for Bourne shell.
# FIXME let zsh use this colorful.
# eval( dircolors -b $HOME/.zsh/lib/dircolors.zsh )
# }}}

# AutoComplete {{{
# auto complete category verbose
autoload -Uz compinit bashcompinit
compinit
bashcompinit
# be verbose, i.e. show descriptions
zstyle ':completion:*' verbose yes
zstyle ':completion:*:descriptions' format '%U%B%d%b%u'
# group by tag names
zstyle ':completion:*' group-name ''

autoload -U compinit
compinit
# auto complete cache
zstyle ':completion::complete:' use-cache on
zstyle ':completion::complete:' cache-path .zcache
zstyle ':completion::cd:' ignore-parents parent pwd
# auto complete options
zstyle ':completion::match:' original only
zstyle ':completion::prefix-1:' completer _complete
zstyle ':completion:predict:' completer _complete
zstyle ':completion:incremental:*' completer _complete _correct
zstyle ':completion:*' completer _complete _prefix _correct _prefix _match _approximate
# auto complete path
zstyle ':completion:' expand 'yes'
zstyle ':completion:' squeeze-shlashes 'yes'
zstyle ':completion::complete:*' '\'
# color complete menu
eval $(dircolors -b)
export ZLSCOLORS="${LSCOLORS}"
zmodload zsh/complist
zstyle ':completion:*' list-colors ${(s.:.)LSCOLORS}
zstyle ':completion:::kill::processes' list-colors '=(#b) #([0-9]#)=0=01;31'
# command kill complete
compdef pkill=kill
compdef pkill=killall
zstyle ':completion:::kill:' menu yes select
zstyle ':completion:::::processes' force-list always
zstyle ':completion::processes' command 'ps -au$USER'
# complete groups
zstyle ':completion::matches' group 'yes'
zstyle ':completion:' group-name ''
zstyle ':completion::options' description 'yes'
zstyle ':completion::options' auto-description '%d'
zstyle ':completion::descriptions' format $'\e[01;33m -- %d --\e[0m'
zstyle ':completion::messages' format $'\e[01;35m -- %d --\e[0m'
zstyle ':completion:*:warnings' format $'\e[01;31m -- No Matches Found --\e[0m'
# }}}

# [ auto-fu.zsh ] {{{
    ## way-1: source it
    ## 1) source this file.
    #source $ZSH/plugins/auto-fu/auto-fu.zsh
    ## 2) establish `zle-line-init' containing `auto-fu-init' something like below.
    #zle-line-init () {auto-fu-init;}; zle -N zle-line-init
    ## 3) use the _oldlist completer something like below.
    #zstyle ':completion:*' completer _oldlist _complete
    ## (If you have a lot of completer, please insert _oldlist before _complete.)
    ## 4) establish `zle-keymap-select' containing `auto-fu-zle-keymap-select'.
    #zle -N zle-keymap-select auto-fu-zle-keymap-select
    ## (This enables the afu-vicmd keymap switching coordinates a bit.)

    ## way-2: zcompile the necessary functions.
    ## *1) zcompile the defined functions. (generates ~/.zsh/auto-fu.zwc)
    #A=$ZSH/plugins/auto-fu/auto-fu.zsh; (zsh -c "source $A ; auto-fu-zcompile $A ~/.zsh/plugins/auto-fu")
    ## *2) source the zcompiled file instead of this file and some tweaks.
    #source ~/.zsh/plugins/auto-fu/auto-fu; auto-fu-install
    ## *3) establish `zle-line-init' and such (same as a few lines above).

    ## configuration {{{
    #zle-line-init () {auto-fu-init;}; zle -N zle-line-init
    #zstyle ':completion:*' completer _oldlist _complete
    #zle -N zle-keymap-select auto-fu-zle-keymap-select
    ## ~~~~~~~~~~~~~~~
    ## zstyle ':auto-fu:highlight' input bold
    #zstyle ':auto-fu:highlight' input fg=green
    #zstyle ':auto-fu:highlight' completion fg=red,bold
    #zstyle ':auto-fu:highlight' completion/one fg=green,bold,underline
    ## zstyle ':auto-fu:var' postdisplay $'\n-azfu-'
    #zstyle ':auto-fu:var' postdisplay $'\n ♪ »'
    #zstyle ':auto-fu:var' postdisplay/clearp 'yes' # FIXME cleanup init zcompile.
    #zstyle ':auto-fu:var' enable all
    #zstyle ':auto-fu:var' disable magic-space
    ##zstyle ':auto-fu:var' track-keymap-skip opp
    #clear # clear zcompile output
    ## }}}

    # clean version {{{
    # precompiled source
    function () {
    local A
    A=~/.zsh/custom/auto-fu/auto-fu.zsh
    [[ -e "${A:r}.zwc" ]] && [[ "$A" -ot "${A:r}.zwc" ]] ||
    zsh -c "source $A; auto-fu-zcompile $A ${A:h}" >/dev/null 2>&1
    }
    source ~/.zsh/custom/auto-fu/auto-fu; auto-fu-install

    # initialization and options
    function zle-line-init () {auto-fu-init}
    zle -N zle-line-init
    zstyle ':auto-fu:highlight' input bold
    zstyle ':auto-fu:highlight' completion fg=white
    zstyle ':auto-fu:var' postdisplay ''
    zstyle ':completion:*' completer _oldlist _complete

    zle -N zle-keymap-select auto-fu-zle-keymap-select
    # ~~~~~~~~~~~~~~~
    zstyle ':auto-fu:highlight' input bold
    zstyle ':auto-fu:highlight' input fg=green
    zstyle ':auto-fu:highlight' completion fg=red,bold
    zstyle ':auto-fu:highlight' completion/one fg=green,bold,underline
    zstyle ':auto-fu:var' postdisplay $'\n ♪ »'
    zstyle ':auto-fu:var' postdisplay/clearp 'yes'
    zstyle ':auto-fu:var' enable all
    zstyle ':auto-fu:var' disable magic-space
    clear # clear zcompile output
    # }}}

# }}}

# for ls++ perl installation {{{
export PERL_LOCAL_LIB_ROOT="/home/chris/perl5";
export PERL_MB_OPT="--install_base /home/chris/perl5";
export PERL_MM_OPT="INSTALL_BASE=/home/chris/perl5";
export PERL5LIB="/home/chris/perl5/lib/perl5/i686-linux-gnu-thread-multi-64int:/home/chris/perl5/lib/perl5";
export PATH="/home/chris/perl5/bin:$PATH";
# }}}

# gpg-agent require settings & vim plugin vim-gnupg.vim {{{
GPG_TTY=$(tty)
export GPG_TTY
# ssh-agent
zstyle :omz:plugins:ssh-agent agent-forwarding on # enable agent forwarding
zstyle :omz:plugins:ssh-agent id_rsa id_rsa2 id_github # load multiple identies
# }}}

# Zsh filetype association {{{
autoload -U zsh-mime-setup
zsh-mime-setup
# alias -s [extension]=[program]
# so that you only need use <Tab> to complete filename.png,
alias -s png=feh
# }}}

# corrections {{{
# 1:
#zstyle ':completion::approximate:' max-errors 1 numeric
# 2:
zstyle ':completion:' completer _complete _match _approximate
zstyle ':completion::match:' original only
zstyle ':completion::approximate:*' max-errors 1 numeric
# }}}

# history {{{
# add timestamps to command history file.
setopt EXTENDED_HISTORY
# use history for command "cd", cd - [TAB] to go to path history.
setopt AUTOPUSHD
# same history path only keep one.
setopt PUSHDIGNORE_DUPS
# ignore this command in history if add space before command.
setopt HISTIGNORESPACE
# use comment in interactive mode
# }}}

# record sudo command history into syslog {{{
zshaddhistory() {
    cmd=${1%%$'\n'}
    print -sr -- $cmd
    LASTCMD="${(pj:\\\n:)${(f)1}}"
    first_arg=${${(z)LASTCMD}[1]}
    ( [[ `id -u $USER` -eq 0 ]] || [[ $first_arg == sudo ]] ) && logger -t "$USER@${TTY/\/dev\/}[$PWD]" $LASTCMD
}
# }}}
# e.g. $ cmd # this is comment
setopt INTERACTIVE_COMMENTS
# line edit highlight mode
# Ctrl+@ set mark, between marks and cursor is "region".
zle_highlight=(region:bg=magenta # choose region.
                special:bold # special characters
                isearch:underline) # keywords when searching.

# Fcitx {{{
    export XMODIFIERS=@im=fcitx
    export GTK_IM_MODULE=fcitx
    export QT_IM_MODULE=fcitx
# }}}

# taskwarrior {{{
    fpath=($fpath /usr/local/share/doc/task/scripts/zsh)
    autoload -Uz compinit
    compinit

    # be verbose, i.e. show descriptions
    zstyle ':completion:*' verbose yes
    zstyle ':completion:*:descriptions' format '%U%B%d%b%u'

    # group by tag names
    zstyle ':completion:*' group-name ''

    alias t=task
    compdef _task t=task

    # use zstyle to configure completion behavior
    # FIXME premission | autoload colors && color

    zstyle ':completion:*:*:task:*:arguments' list-colors "=(#b) #([^-]#)*=$color[cyan]=$color[bold];$color[blue]"
    zstyle ':completion:*:*:task:*:default' list-colors "=(#b) #([^-]#)*=$color[cyan]=$color[green]"
    zstyle ':completion:*:*:task:*:values' list-colors "=(#b) #([^-]#)*=$color[cyan]=$color[bold];$color[red]"
    zstyle ':completion:*:*:task:*:commands' list-colors "=(#b) #([^-]#)*=$color[cyan]=$color[yellow]"
    #(#b) activates the use of brackets within regular expressions
    #the part to the next = character is a regular expression to be matched
    #color codes are separated with = characters
    #the first code is the default color
    #the other codes define the colors of the 1st, 2nd, etc. pair of brackets
    #(See http://zshwiki.org/home/examples/compsys/colors for a detailed description.)
# }}}

# # Tmux & Screen {{{
# # avoid a possible impact on stability of urxvtd
# # if login_shell, interactive

# #if ! tmux has-session -t Daily; then
#     #exec tmux new-session -s Daily -d
#     ## other setup commands before attaching ...
# #fi
# #exec tmux attach -t Daily

# TMUX_MOD=`[ -z "$TMUX" ] && echo 1`
# TMUX_TERM_LIST=(rxvt-unicode-256color Apple_Terminal iTerm.app)

# _check_term_app() {
#     TP=''
#     if [ -n "$TERM_PROGRAM" ];then
#         TP=$TERM_PROGRAM
#     elif [ -n "$TERM" ]; then
#         TP=$TERM
#     else
#         echo 'Either $TERM or $TERM_PROGRAM is set, cannot determine terimnal name.'
#         return 1
#     fi

#     res=${TMUX_TERM_LIST[@]/${TP}/yes}
#     if [ -n "`echo $res | grep 'yes'`" ]; then
#         return 0
#     else
#         return 1
#     fi
# }

# TIMEOUT=3
# DEFAULT_SESSION=new
# SIGNAL=9
# SELECT_CMD=
# CODE="
# _timeout() {
#     sleep \$1
#     echo \$2
#     kill -\$3 \$4
# }

# _timeout $TIMEOUT $DEFAULT_SESSION $SIGNAL \$\$ &
# SUB_PID=\$!

# SELECT_CMD

# kill -9 \$SUB_PID
# exit
# "

# # Start tmux if no tmux is running under current shell
# if [ "`_check_term_app && echo 1`" = "1" -a "z$TMUX_MOD" = "z1" ];then
#     ## DONE:TODO: If there's no session,create a new one,otherwise show a list for user to select
#     #session_list=(`tmux list-sessions | tr '\n' ','`)
#     session_list=`tmux list-sessions | sed "s/.*/'&'/g" | tr '\n' ' '`
#     if [ -n "$session_list" ];then
#         echo 'Select an session'

#         SELECT_CMD="
#         select session in ${session_list[*]}; do
#             target=\`echo \$session | awk '{print \$1}'\`
#             echo \$target
#             break
#         done
#         "

#         CODE=${CODE/SELECT_CMD/$SELECT_CMD}
#         #echo $CODE > t
#         #echo ------------------------------- >> t
#         target=`bash -c "$CODE"`
#     fi

#     echo target=$target

#     ## Open tmux
#     cmd=tmux
#     if [ -n "$target" -a "$target" != "new" ];then
#         cmd="$cmd attach -t $target"
#     fi
#     eval "$cmd" || echo "Tmux exited abnormally. Exit code $?"
#     exit 0
# fi
# # }}}

# tmux {{{
if [ -n "$TMUX" ]; then # if terminal is Tmux.
    echo "Now, you're in tmux."
elif [ -n "$SCREEN" ]; then
    echo "Now, you're in screen"
else
    tmux
fi
# }}}

# vim: foldmethod=marker
